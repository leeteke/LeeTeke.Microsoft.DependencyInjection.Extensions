using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;

namespace LeeTeke.Microsoft.DependencyInjection.Extensions.AOT
{
    [Generator()]
    public class DIIncrementalGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var compilation = context.CompilationProvider;
            context.RegisterSourceOutput(compilation, (sourceProductionContext, c) =>
            {

                string _IServiceCollection = "global::Microsoft.Extensions.DependencyInjection.IServiceCollection";

                var codeCube = GetCoreCodeSource(c);
                // Build up the source code
                string source =
                    $$"""
                    // <auto-generated/>
                    using Microsoft.Extensions.DependencyInjection;
                    namespace LeeTeke.Microsoft.DependencyInjection.Extensions.AOT
                   {
                   
                    public static class ServiceCollectionServiceExtensionsAOT
                    {
                      private static bool s_initialized;
                      private static readonly object s_initializeLock = new object();

                      public static {{_IServiceCollection}} AddFromAssembliyAOT(this {{_IServiceCollection}} services)
                      {
                         if (s_initialized)
                          {
                            return services;
                          }
                        
                          lock (s_initializeLock)
                          {
                            if (s_initialized)
                             {
                             return services;
                             }
                             s_initialized = true;
                             {{codeCube}}
                           return services;
                         }
                     }
                 }
                }
                
                """;

                sourceProductionContext.AddSource($"DIIncrementalGenerator.g.cs", source);

            });
        }


        private string GetCoreCodeSource(Compilation compilation)
        {
            StringBuilder sb = new StringBuilder();
            var de = compilation.Assembly.GetAttributes().Where(p => p.AttributeClass.ToString().StartsWith("LeeTeke.Microsoft.DependencyInjection.Extensions.DependencyRegisterAttribute")).ToList();
            foreach (var item in compilation.SourceModule.ReferencedAssemblySymbols)
            {
               de.AddRange(  item.GetAttributes().Where(p => p.AttributeClass.ToString().StartsWith("LeeTeke.Microsoft.DependencyInjection.Extensions.DependencyRegisterAttribute")));
            }
            foreach (var entry in de)
            {
                if (entry.ConstructorArguments.Length == 2)
                {
                    var @implementor = entry.ConstructorArguments[0].Value;
                    var @type = entry.ConstructorArguments[1].Value.ToString();
                    switch (@type)
                    {
                        case "0":
                            sb.AppendLine($"services.AddSingleton(typeof(global::{@implementor}));");
                            break;
                        case "1":
                            sb.AppendLine($"services.AddTransient( typeof(global::{@implementor}));");
                            break;
                        case "2":
                            sb.AppendLine($"services.AddScoped(typeof(global::{@implementor}));");
                            break;
                        default:
                            break;
                    }
                }
                else if (entry.ConstructorArguments.Length == 3)
                {

                    if (entry.ConstructorArguments[0].Kind == TypedConstantKind.Type)
                    {

                        var @interface = entry.ConstructorArguments[0].Value;
                        var @implementor = entry.ConstructorArguments[1].Value;
                        var @type = entry.ConstructorArguments[2].Value.ToString();



                        switch (@type)
                        {
                            case "0":
                                sb.AppendLine($"services.AddSingleton(typeof(global::{@interface}), typeof(global::{@implementor}));");
                                break;
                            case "1":
                                sb.AppendLine($"services.AddTransient(typeof(global::{@interface}), typeof(global::{@implementor}));");
                                break;
                            case "2":
                                sb.AppendLine($"services.AddScoped(typeof(global::{@interface}), typeof(global::{@implementor}));");
                                break;
                            default:
                                break;
                        }
                    }
                    else if (entry.ConstructorArguments[0].Kind == TypedConstantKind.Array)
                    {

                        var @implementor = entry.ConstructorArguments[1].Value;
                        var @type = entry.ConstructorArguments[2].Value.ToString();
                        var allInterfaces = entry.ConstructorArguments[0].Values.Select(p => p.Value.ToString());
                        switch (@type)
                        {
                            case "0":
                                sb.AppendLine($"services.AddSingleton(typeof(global::{@implementor}));");
                                foreach (var @interface in allInterfaces)
                                {
                                    if (@interface != implementor.ToString())
                                    {
                                        sb.AppendLine($"services.AddSingleton(typeof(global::{@interface}), p=>p.GetService(typeof(global::{@implementor})));");
                                    }
                                }


                                break;
                            case "1":
                                sb.AppendLine($"services.AddTransient(typeof(global::{@implementor}));");
                                foreach (var @interface in allInterfaces)
                                {
                                    if (@interface != implementor.ToString())
                                    {
                                        sb.AppendLine($"services.AddTransient(typeof(global::{@interface}), p=>p.GetService(typeof(global::{@implementor})));");
                                    }
                                }
                                break;
                            case "2":
                                sb.AppendLine($"services.AddScoped(typeof(global::{@implementor}));");
                                foreach (var @interface in allInterfaces)
                                {
                                    if (@interface != implementor.ToString())
                                    {
                                        sb.AppendLine($"services.AddScoped(typeof(global::{@interface}), p=>p.GetService(typeof(global::{@implementor})));");
                                    }
                                }
                                break;
                            default:
                                break;
                        }


                    }
                }
            }



            return sb.ToString();
        }

    }
}
